# Basic Data Structures and Algorithms 

基础数据结构和算法笔记。

### Quick Sort
快排的核心时分治。排序过程大致分为三个步骤：
1. 定基准——选定一个主元素pivot
1. 分区——让所有小于pivot的元素都位于它左侧，所有大于等于pivot的元素都位于它右侧
1. 分而治之——递归调用此分区过程，处理pivot左侧和右侧序列

看到用`Python`写的“一句话快排”，极好地描述了以上过程：

		return qsort([x for x in A[1:] if x < pivot]) + [pivot] + qsort([x for x in A[1:] if x >= pivot])
		
三个步骤中，1和3都没什么可说的，主要的操作都在第2步分区。分区有很多种方法，只要能达到预期的效果即可。国内数据结构教材惯用的写法，可以称之为“挖坑填数法”，感觉不是很优雅，理解起来也不够直观。这里选择两种非常优雅的方法，作个笔记。

#### 分区方法一：快慢指针
对于待划分区间`[L, R]`，取基准元素`pivot = A[L]`，使用下标`m`记录遍历到数组第i个元素时，当前partition的索引（作用相当于一个计数器），那么对数组完成一次遍历时，`m`就正好位于`pivot`应当放在的位置，分区结束。对`[L, m - 1]`和`[m + 1, R]`两个子分区递归处理。**递归终止条件：L >= R，即左右边界相等或错位。**

`TODO` 貌似这里说的不对
> 比较`A[i]`和`pivot`时只能使用`<`而不能用`<=`，因为只有取`<`才能进入收敛条件，`<=`则可能出现死循环，因为在`=`时第一个元素可能保持不变进而产生死循环。

图解：
![](http://algorithm.yuanbin.me/shared-files/images/qsort2.png)

#### 分区方法二：首尾指针
对于待划分区间`[L, R]`，取基准元素`pivot = A[L]`，使用首指针`i`从左向右扫描，遇到 !< pivot的元素时暂停，准备与某<pivot的元素交换；使用尾指针`j`从右向左扫描，遇到 !>= pivot的元素时暂停，准备与某 >= pivot的元素交换。这样循环处理，当`i`与`j`错位时停止，`j`就是`pivot`应当放在的位置。

**解释为什么`pivot`最后应该放在`j`而不是`i`**：循环条件是`while (i <= j)`，所以当循环退出时，必有`j < i`，即`j`落在了`i`扫描过的位置。`i`扫描过的位置意味着，这个位置上元素是小于`pivot`的，这时执行`exch(A, L, j)`正能得到预期的目的。

图解：
![](http://algs4.cs.princeton.edu/23quicksort/images/partitioning.png)

### Binary Search
模版一：lower/upper bound

[代码]()
解释这个模版的几个非常优雅的处理：
1. `while`循环中`lb + 1 < ub`，不加等号，因为加等号容易引起死循环。初始化满足`lb < ub`时，最后退出循环一定会出现`lb + 1 == ub`.
1. `mid = lb + (ub - lb) / 2`，可防止两数相加后溢出。
1. `lb`和`ub`的初始化，初始化为数组的两端以外，这种方式比起`0`和`A.length - 1`有不少优点，详述如下。

求插入位置的索引，可以分三种典型情况：
1. 目标值在数组范围之内，最后返回值一定是`lb + 1`
1. 目标值比数组最小值还小，此时`lb`一直为`-1`，故最后返回`lb + 1`也正确。**这里可以将－1理解成数组前方一个更小的值。**
1. 目标值大于等于数组最后一个值，由于循环推出条件为`lb + 1 == ub`，那么循环退出时一定有`lb = A.length - 1`，也应返回`lb + 1`

综上所述，返回`lb + 1`是非常优雅的实现。其实以上三种情况也可以统一为一种来理解，即索引`lb = -1`对应于数组前方一个非常小的数，索引`ub = A.length`对应数组后方一个非常大的数，那么要插入的位置就一定介于`lb`和`ub`之间了。

**有时复杂的边界条件处理可以通过“补项”这种优雅的方式巧妙处理。**