# Basic Data Structures and Algorithms 

基础数据结构和算法笔记。

### Quick Sort
写法一：使用一根指针(或称下标)完成分区
思路：
对于待排序区间`[L, R]`，取基准元素`pivot = A[L]`，使用下标`m`记录遍历到数组第i个元素时，当前partition的索引，那么对数组完成一次遍历时，`m`就正好位于`pivot`应当放在的位置，分区结束。对`[L, m - 1]`和`[m + 1, R]`两个子分区递归处理。**递归终止条件：L >= R，即左右边界相等或错位。**

> 比较`A[i]`和`pivot`时只能使用`<`而不能用`<=`，因为只有取`<`才能进入收敛条件，`<=`则可能出现死循环，因为在`=`时第一个元素可能保持不变进而产生死循环。

参考图示：
![](http://algorithm.yuanbin.me/shared-files/images/qsort2.png)

写法二：使用两根指针完成分区
`TODO` 书上的解释说数组元素均相等时，partition恰好得中间位置，分析不对

参考图示：
![](http://algs4.cs.princeton.edu/23quicksort/images/partitioning.png)

### Binary Search
模版一：lower/upper bound

[代码]()
解释这个模版的几个非常优雅的处理：
1. `while`循环中`lb + 1 < ub`，不加等号，因为加等号容易引起死循环。初始化满足`lb < ub`时，最后退出循环一定会出现`lb + 1 == ub`.
1. `mid = lb + (ub - lb) / 2`，可防止两数相加后溢出。
1. `lb`和`ub`的初始化，初始化为数组的两端以外，这种方式比起`0`和`A.length - 1`有不少优点，详述如下。

求插入位置的索引，可以分三种典型情况：
1. 目标值在数组范围之内，最后返回值一定是`lb + 1`
1. 目标值比数组最小值还小，此时`lb`一直为`-1`，故最后返回`lb + 1`也正确。**这里可以将－1理解成数组前方一个更小的值。**
1. 目标值大于等于数组最后一个值，由于循环推出条件为`lb + 1 == ub`，那么循环退出时一定有`lb = A.length - 1`，也应返回`lb + 1`

综上所述，返回`lb + 1`是非常优雅的实现。其实以上三种情况也可以统一为一种来理解，即索引`lb = -1`对应于数组前方一个非常小的数，索引`ub = A.length`对应数组后方一个非常大的数，那么要插入的位置就一定介于`lb`和`ub`之间了。

**有时复杂的边界条件处理可以通过“补项”这种优雅的方式巧妙处理。**